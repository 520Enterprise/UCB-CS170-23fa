# 图论

## DFS

记录一下一个OI中没怎么学会的知识点

![image-20231218155703964](https://img2023.cnblogs.com/blog/1892247/202312/1892247-20231218155705406-1914298355.png)

上图是一个DFS遍历，`pre`数组记录了每个节点最初被访问的时间，`post`数组记录了每个节点最后被访问的时间(进出栈的时间)

根据两个数组，可以将所有边分为四类
- 树边(Tree Edge): DFS 树中的边
- 后向边(Back Edge): 从一个节点到其祖先的边
- 前向边(Forward Edge): 从一个节点到其子孙(非直接)的边
- 横叉边(Cross Edge): 除了上述三种边之外的边(在 DFS 树中要先往上再往下)
  - 注意横叉边肯定是从右往左的，否则如下图，虚线边会先被访问，就不是横叉边而是树边了
  - 这也意味着无向图不会有横叉边
  - ![image-20231218161026668](https://img2023.cnblogs.com/blog/1892247/202312/1892247-20231218161041667-2075725473.png)

它们的性质如下

![image-20231218161547902](https://img2023.cnblogs.com/blog/1892247/202312/1892247-20231218161549249-2117146904.png)

## Kosaraju 算法

给定一个图 $G = (V, E)$，考虑如何求出它的强连通分量(SCC)

![image-20231218163639655](https://img2023.cnblogs.com/blog/1892247/202312/1892247-20231218163641158-650987202.png)

如上图，如果我们将其看成一个由 SCC 构成的 DAG，在叶节点进行一次 DFS 找到所有能访问到的节点，就是一个 SCC(因为叶节点只进不出)，然后删去这个叶节点，依次类推。

所以我们只需要设计一个算法，使得他能够“倒序”访问这些节点即可

我们考虑使用之前定义的 `post` 数组，如果在 $G$ 中有从强连通分量 $C$ 到 $C'$ 的边，那么 $C$ 中的最大 `post` 数一定大于 $C'$ 中的最大 `post` 数，所以最大的 `post` 数对应的节点一定是源(source)

我们定义图的转置 $G^T = (V, E^T)$, 其中 $E^T = \{(u, v) | (v, u) \in E\}$，通俗的说就是将所有边的方向反过来，那么在 $G^T$ 中，最大的 `post` 数对应的节点一定是 $G$ 中的汇(sink)，从大到小依次是原图中汇到源的拓扑序

1. 在 $ G^T $ 上运行 DFS, 得到每个节点的 `post` 
2. 在 $ G $ 上运行 DFS, 按照 `post` 从大到小的顺序访问节点，每次访问到的节点都是一个 SCC



## HW4Q4 半联通

对于一个有向无环图，定义半联通性(semiconnectivity)为：对于任意两个节点 $u, v$，存在一条从 $u$ 到 $v$ 的路径或者从 $v$ 到 $u$ 的路径。求证：对于一个有向无环图，它是半联通的充要条件是存在一条可以访问到所有节点的路径

充分性显然，下证必要性
对于这个有向无环图，可以进行拓扑排序，得到一个拓扑序列 $v_1, v_2, \cdots, v_n$，因为有向无环，所以没有后向边，考虑拓扑序列中的任意点对 $v_i, v_{i+1}$，只能存在 $v_i \rightarrow v_{i+1}$ 的边，否则 $v_{i+1}$ 就会有 $v_i$ 的后向边，所以 $v_i$ 到 $v_{i+1}$ 有一条路径，那么我们就找到了一条从 $v_1$ 到 $v_n$ 的路径

## HW4Q5 2-SAT问题
一个2-SAT问题是指，给定一个布尔表达式，其中每个子句都是两个文字的析取，求是否存在一种赋值方式使得表达式为真。例如，$(x_1 \vee x_2) \wedge (\neg x_1 \vee x_3) \wedge (\neg x_2 \vee \neg x_3)$。

### 建图
把合取转化为蕴含，然后把蕴含转化为边，最后把每个文字转化为两个点，分别表示自身和否定(如 $x_1$ 和 $\neg x_1$)，然后把蕴含转化为边，如 $(x_1 \vee x_2)$ 转化为 $(\neg x_1 \rightarrow x_2) \wedge (\neg x_2 \rightarrow x_1)$，然后把蕴含转化为边

### 获得答案
2-SAT 问题有解等价于图中不存在 $x$ 和 $\neg x$ 在同一个强连通分量中，因为如果存在这样的强连通分量，那么就有 $x \rightarrow \neg x$ 和 $\neg x \rightarrow x$，所以 $x$ 和 $\neg x$ 不能同时为真，所以没有解
反之如果不存在这样的强连通分量，那么就可以按拓扑序列从后往前赋值即可(注意，赋值一个文字的否定为真意味着将其赋值为假)，对一个 SCC 赋值完之后考虑它的父 SCC,

# 近似算法

近似算法中一个重要的定义是近似比(approximation ratio): 一个算法的解与最优解的比值

一般贪心算法都是比较优秀的近似算法, 如集合覆盖问题

![image-20231218154415751](https://img2023.cnblogs.com/blog/1892247/202312/1892247-20231218154417241-926185083.png)

一个最直观的想法就是每次选能覆盖最多的集合，这显然不是最优(如上图)，但是可以证明它的近似比为 $ln n$

- 事实上如果最优解的集合数为 $k$, 那么根据平均数原理, 至少有一个集合覆盖了 $\dfrac{n}{k}$ 个元素, 每次选覆盖最多的集合可以使得原集合的大小缩减到之前的 $\dfrac{k-1}{k}$, 经过 $k \ln n$ 次迭代后, 剩下的集合数为 $1$

# 贪心算法

## Horn-SAT
定义: 一个 Horn-SAT 公式是一个由 Horn 子句构成的公式, 其中 Horn 子句是至多有一个正文字(positive literal)的合取范式

一共只有两种: $\neg x_1 \vee \neg x_2 \vee \cdots \vee \neg x_i$ 和 $\neg x_1 \vee \neg x_2 \vee \cdots \vee \neg x_j \vee x_{j+1}$
其中后者可以写成蕴含形式: $  (x_1 \wedge x_2 \wedge \cdots \wedge x_j) \rightarrow x_{j+1}$

算法很简单，一开始所有变量都为假，然后每次都看哪个蕴含式的前提都为真，就把它的结论设为真。一开始只有单个变量的"蕴含式"(没有前提)会被考虑，后面就是看哪些前提一定满足，就把结论设为真

![image-20231218204324917](https://img2023.cnblogs.com/blog/1892247/202312/1892247-20231218204326528-1398759813.png)